<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Guardian Quant - Experimental Lab</title>
  <style>
    :root{
      --bg:#0a1018;
      --panel:#111b2a;
      --panel-2:#162437;
      --line:#2a3f5d;
      --text:#d9e6f4;
      --muted:#96a9c1;
      --ok:#41d497;
      --warn:#ffc56d;
      --bad:#ff7979;
      --accent:#59b7ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:"Segoe UI",Tahoma,sans-serif;
      background:linear-gradient(180deg,#09101a 0%,#0d1522 100%);
      color:var(--text);
    }
    .wrap{max-width:1300px;margin:0 auto;padding:20px}
    .title{display:flex;justify-content:space-between;align-items:flex-end;gap:16px;margin-bottom:16px}
    .title h1{margin:0;font-size:22px}
    .title small{color:var(--muted)}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    .card{
      background:linear-gradient(180deg,var(--panel) 0%,var(--panel-2) 100%);
      border:1px solid var(--line);
      border-radius:12px;
      padding:14px;
    }
    .card h2{margin:0 0 10px;font-size:15px;letter-spacing:.4px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:end}
    label{display:flex;flex-direction:column;gap:6px;color:var(--muted);font-size:12px}
    input,select,button,textarea{
      background:#0d1726;border:1px solid #2f4767;color:var(--text);
      border-radius:8px;padding:8px 10px;font-size:13px;
    }
    textarea{min-height:44px;min-width:320px}
    button{cursor:pointer;background:#173253}
    button:hover{filter:brightness(1.08)}
    table{width:100%;border-collapse:collapse;font-size:12px}
    th,td{border-bottom:1px solid #28405f;padding:7px 6px;text-align:left}
    th{color:#a9c2df;font-weight:600}
    .buy{color:var(--ok);font-weight:700}
    .hold{color:var(--warn);font-weight:700}
    .watch{color:var(--accent);font-weight:700}
    .log{
      font-family:Consolas,monospace;font-size:12px;max-height:250px;overflow:auto;
      background:#0a1320;border:1px solid #25405f;border-radius:8px;padding:8px;
    }
    .metrics{display:grid;grid-template-columns:repeat(6,minmax(0,1fr));gap:8px}
    .k{background:#0c1726;border:1px solid #26405e;border-radius:8px;padding:8px}
    .k b{display:block;font-size:17px;margin-top:6px}
    .full{grid-column:1/-1}
    canvas{width:100%;height:220px;border:1px solid #24415f;border-radius:8px;background:#0b1320}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">
      <div>
        <h1>Guardian Quant - Experimental Lab (Isolado)</h1>
        <small>Ambiente paralelo para pesquisa de modelos sem tocar core.</small>
      </div>
      <small id="labClock">--:--:--</small>
    </div>

    <div class="card">
      <h2>Scanner Ranking</h2>
      <div class="row">
        <label>Symbols (CSV)
          <textarea id="symbolsInput">BTCUSDT,ETHUSDT,BNBUSDT,SOLUSDT,XRPUSDT,ADAUSDT</textarea>
        </label>
        <label>Intervalo
          <select id="intervalInput">
            <option value="5m">5m</option>
            <option value="15m" selected>15m</option>
            <option value="30m">30m</option>
            <option value="1h">1h</option>
          </select>
        </label>
        <label>Limite candles
          <input id="limitInput" type="number" min="260" max="1500" value="1200" />
        </label>
        <label>Near %
          <input id="nearPctInput" type="number" min="0.0001" max="0.02" step="0.0001" value="0.002" />
        </label>
        <button id="btnScan">Executar Scanner</button>
      </div>
      <div style="margin-top:10px;overflow:auto">
        <table id="scannerTable">
          <thead>
            <tr>
              <th>Symbol</th><th>Regime</th><th>Breakout</th><th>NearBreakout</th><th>DistToBreakout%</th><th>ATRexp</th><th>VolExp</th><th>slopeNorm</th><th>prob2R</th><th>ProbOcc</th><th>ProbSucc</th><th>EdgeTrades</th><th>EdgeOk</th><th>Momentum</th><th>Expectancy</th><th>Sinal</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h2>Model Comparator</h2>
        <div style="overflow:auto">
          <table id="comparatorTable">
            <thead>
              <tr>
                <th>Symbol</th>
                <th>Score Model</th>
                <th>Momentum Model</th>
                <th>Prob Model</th>
                <th>Melhor</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="card">
        <h2>Backtest Runner</h2>
        <div class="row">
          <label>Symbol
            <input id="btSymbol" value="BTCUSDT" />
          </label>
          <label>Modelo
            <select id="btModel">
              <option value="score">Score Model</option>
              <option value="momentum" selected>Momentum Model</option>
              <option value="prob">Prob Model</option>
            </select>
          </label>
          <label>Intervalo
            <select id="btInterval">
              <option value="5m">5m</option>
              <option value="15m" selected>15m</option>
              <option value="30m">30m</option>
              <option value="1h">1h</option>
            </select>
          </label>
          <label>Limite candles
          <input id="btLimit" type="number" min="260" max="1500" value="1200" />
          </label>
          <button id="btnBacktest">Rodar Backtest</button>
        </div>
        <div class="metrics" style="margin-top:10px" id="btMetrics">
          <div class="k"><span>Net Profit</span><b id="mNet">$0.00</b></div>
          <div class="k"><span>WinRate</span><b id="mWin">0.00%</b></div>
          <div class="k"><span>Expectancy</span><b id="mExp">$0.00</b></div>
          <div class="k"><span>Max DD</span><b id="mDd">0.00%</b></div>
          <div class="k"><span>Trades</span><b id="mTrades">0</b></div>
          <div class="k"><span>Motivo quando 0</span><b id="mBlock">-</b></div>
        </div>
        <div class="full" style="margin-top:10px">
          <canvas id="equityCanvas" width="600" height="220"></canvas>
        </div>
      </div>

      <div class="card">
        <h2>Grid Search</h2>
        <div class="row">
          <label>Symbol
            <input id="gsSymbol" value="BTCUSDT" />
          </label>
          <label>Modelo
            <select id="gsModel">
              <option value="momentum" selected>Momentum Model</option>
              <option value="prob">Prob Model</option>
              <option value="score">Score Model</option>
            </select>
          </label>
          <label>Intervalo
            <select id="gsInterval">
              <option value="5m">5m</option>
              <option value="15m" selected>15m</option>
              <option value="30m">30m</option>
              <option value="1h">1h</option>
            </select>
          </label>
          <label>Limite candles
            <input id="gsLimit" type="number" min="260" max="1500" value="1200" />
          </label>
          <button id="btnRunGrid">Run Grid</button>
          <button id="btnApplyBest" class="secondary">Apply Best Params</button>
        </div>
        <div class="small" id="gridSummary" style="margin-top:8px;color:#96a9c1">Aguardando execuÃ§Ã£o...</div>
        <div style="margin-top:8px;overflow:auto">
          <table id="gridTable">
            <thead>
              <tr>
                <th>#</th><th>stopAtr</th><th>rTarget</th><th>brkLb</th><th>chop</th><th>bull</th><th>Trades</th><th>Net</th><th>Exp</th><th>MaxDD</th><th>Status</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="card full">
        <h2>Logs Institucionais</h2>
        <div class="log" id="logsPanel"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import { fetchKlines, parseKlines } from '../js/binance.js';
    import { experimentalState } from './experimentalState.js';
    import { nearBreakout, scanRank } from './momentumModel.js';
    import { compareModels } from './modelComparator.js';
    import { runBacktest, drawEquityCurve } from './visualBacktest.js';
    import { runGridSearch, defaultGrid } from './gridSearch.js';
    import { EdgeEngine } from './edgeEngine.js';
    import { DEFAULT_EXPERIMENTAL_CFG, mergeExperimentalCfg } from './experimentalConfig.js';

    const $ = (id) => document.getElementById(id);
    const fmtUsd = (n) => (Number(n) || 0).toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:2});
    const fmtPct = (n) => `${(Number(n) * 100).toFixed(2)}%`;
    const logsPanel = $('logsPanel');
    let lastGridBest = null;
    experimentalState.cfg = mergeExperimentalCfg(DEFAULT_EXPERIMENTAL_CFG, experimentalState.cfg || {});

    function logInstitutional(payload){
      const fmtNA = (v, digits = 4) => (v == null || !Number.isFinite(Number(v))) ? 'N/A' : Number(v).toFixed(digits);
      const line = [
        `[${new Date().toLocaleTimeString('pt-BR',{hour12:false})}]`,
        `regime=${payload.regime}`,
        `breakout=${payload.breakoutFlag ? 1 : 0}`,
        `atrExp=${payload.atrExp ? 1 : 0}`,
        `volExp=${payload.volExp ? 1 : 0}`,
        `momentum=${fmtNA(payload.momentumScore)}`,
        `prob2R=${fmtNA(payload.probability)}`,
        `rollExp=${fmtNA(payload.rollingNetExpectancy)}`,
        `edgeTrades=${Number(payload.edgeTradesCount || 0)}`,
        `edgeOk=${payload.edgeOk ? 1 : 0}`,
        `decision=${payload.decision || 'HOLD'}`,
        `reason=${payload.reason || 'NA'}`,
        `slippage=${Number(payload.slippageEst || 0).toFixed(6)}`
      ].join(' ');
      experimentalState.logs.unshift(line);
      if (experimentalState.logs.length > 300){
        experimentalState.logs.splice(300);
      }
      logsPanel.textContent = experimentalState.logs.join('\n');
    }

    async function loadSeries(symbol, interval, limit){
      const kl = await fetchKlines(symbol, interval, limit);
      return parseKlines(kl);
    }

    function renderScanner(rows){
      const tbody = $('scannerTable').querySelector('tbody');
      const fmtNA = (v, digits = 4) => (v == null || !Number.isFinite(Number(v))) ? 'N/A' : Number(v).toFixed(digits);
      tbody.innerHTML = rows.map((r) => `
        <tr>
          <td>${r.symbol}</td>
          <td>${r.regime}</td>
          <td>${r.breakoutFlag ? 'YES' : 'NO'}</td>
          <td>${r.nearBreakout ? 'YES' : 'NO'}</td>
          <td>${Number.isFinite(Number(r.distToBreakoutPct)) ? `${(Number(r.distToBreakoutPct) * 100).toFixed(3)}%` : 'N/A'}</td>
          <td>${r.atrExp ? 'YES' : 'NO'}</td>
          <td>${r.volExp ? 'YES' : 'NO'}</td>
          <td>${Number(r.slopeNorm || 0).toFixed(3)}</td>
          <td>${r.prob2R == null ? 'N/A' : `${(Number(r.prob2R) * 100).toFixed(1)}%`}</td>
          <td>${Number(r.probOcc || 0)}</td>
          <td>${Number(r.probSucc || 0)}</td>
          <td>${Number(r.edgeTradesCount || 0)}</td>
          <td>${r.edgeOk ? 'YES' : 'NO'}</td>
          <td>${fmtNA(r.momentumScore)}</td>
          <td>${Number(r.rollingNetExpectancy || 0).toFixed(4)}</td>
          <td class="${r.scanSignal === 'BUY' ? 'buy' : (r.scanSignal === 'WATCH' ? 'watch' : 'hold')}">${r.scanSignal || r.signal}</td>
        </tr>
      `).join('');
    }

    function renderComparator(rows){
      const tbody = $('comparatorTable').querySelector('tbody');
      const fmtNA = (v, digits = 2) => (v == null || !Number.isFinite(Number(v))) ? 'N/A' : Number(v).toFixed(digits);
      tbody.innerHTML = rows.map((r) => `
        <tr>
          <td>${r.symbol}</td>
          <td>${r.scoreDecision.signal} (${fmtNA(r.scoreDecision.score)})</td>
          <td>${r.momentumDecision.signal} (${fmtNA(r.momentumDecision.score)})</td>
          <td>${r.probDecision.signal} (${r.probDecision.probability == null ? 'N/A' : `${(Number(r.probDecision.probability) * 100).toFixed(1)}%`})</td>
          <td><b>${r.best}</b></td>
        </tr>
      `).join('');
    }

    async function runScanner(){
      const symbols = $('symbolsInput').value.split(',').map((s) => s.trim().toUpperCase()).filter(Boolean);
      const interval = $('intervalInput').value;
      const limit = Math.max(260, Number($('limitInput').value || 1200));
      const nearPct = Math.max(0.0001, Number($('nearPctInput').value || 0.002));
      experimentalState.cfg = mergeExperimentalCfg(DEFAULT_EXPERIMENTAL_CFG, experimentalState.cfg || {});

      const scannerRows = [];
      const comparatorRows = [];
      for (const symbol of symbols){
        try{
          const series = await loadSeries(symbol, interval, limit);
          const cmp = compareModels(symbol, series, experimentalState);
          const mom = cmp.momentumDecision;
          const prob2R = cmp.probDecision?.prob2R ?? cmp.probDecision?.probability ?? null;
          const probOcc = Number(cmp.probDecision?.occ || cmp.probDecision?.sampleSize || 0);
          const probSucc = Number(cmp.probDecision?.succ || cmp.probDecision?.wins2R || 0);
          const nb = nearBreakout(series, Number(experimentalState.cfg?.breakoutLookback || 12), nearPct);
          const scanSignal = mom.signal === 'BUY'
            ? 'BUY'
            : (nb.nearBreakout && !mom.breakoutFlag ? 'WATCH' : 'HOLD');
          scannerRows.push({ ...mom, ...nb, prob2R, probOcc, probSucc, scanSignal });
          comparatorRows.push(cmp);

          const holdReason = mom.regime === 'CHOP'
            ? 'CHOP_BLOCK'
            : (mom.reason === 'NON_BULL_REQUIRES_PROB' ? 'PROB_FAIL' : 'BREAKOUT_FAIL');
          const scanReason = scanSignal === 'WATCH'
            ? `WATCH_NEAR_BREAKOUT + distToBreakoutPct=${Number(nb.distToBreakoutPct || 0).toFixed(6)}`
            : (scanSignal === 'BUY' ? 'MOMENTUM_SETUP' : holdReason);
          logInstitutional({
            regime: mom.regime,
            breakoutFlag: mom.breakoutFlag,
            atrExp: mom.atrExp,
            volExp: mom.volExp,
            momentumScore: mom.momentumScore,
            probability: prob2R,
            rollingNetExpectancy: mom.rollingNetExpectancy,
            edgeTradesCount: mom.edgeTradesCount,
            edgeOk: mom.edgeOk,
            decision: scanSignal,
            reason: scanReason,
            slippageEst: 0.0006
          });
        } catch (err){
          logInstitutional({
            regime: 'ERR',
            breakoutFlag: false,
            atrExp: false,
            volExp: false,
            momentumScore: null,
            probability: null,
            rollingNetExpectancy: null,
            edgeTradesCount: 0,
            edgeOk: false,
            decision: 'HOLD',
            reason: 'SCANNER_ERROR',
            slippageEst: 0
          });
          console.error(`Erro scanner ${symbol}`, err);
        }
      }

      const rankedRows = scanRank(scannerRows);
      experimentalState.scannerRows = rankedRows;
      experimentalState.comparatorRows = comparatorRows;
      renderScanner(rankedRows);
      renderComparator(comparatorRows);
    }

    async function runBacktestUI(){
      const symbol = $('btSymbol').value.trim().toUpperCase();
      const interval = $('btInterval').value;
      const modelType = $('btModel').value;
      const limit = Math.max(260, Number($('btLimit').value || 1200));

      const series = await loadSeries(symbol, interval, limit);
      const result = runBacktest(symbol, modelType, series, {
        edgeEngine: experimentalState.edgeEngine,
        cfg: mergeExperimentalCfg(DEFAULT_EXPERIMENTAL_CFG, experimentalState.cfg || {})
      });
      if (result.error){
        logInstitutional({
          regime: 'BT_ERR',
          breakoutFlag: false,
          atrExp: false,
          volExp: false,
          momentumScore: null,
          probability: null,
          rollingNetExpectancy: null,
          edgeTradesCount: Number(experimentalState.edgeEngine?.tradesCount || 0),
          edgeOk: false,
          decision: 'HOLD',
          reason: result.error,
          slippageEst: 0
        });
        return;
      }
      $('mNet').textContent = fmtUsd(result.netProfit);
      $('mWin').textContent = fmtPct(result.winRate);
      $('mExp').textContent = fmtUsd(result.expectancy);
      $('mDd').textContent = fmtPct(result.maxDD);
      $('mTrades').textContent = String(result.trades || 0);
      const block = (result.trades || 0) > 0
        ? '-'
        : Object.entries(result.blockReasons || {}).sort((a,b)=>b[1]-a[1])[0]?.[0] || 'NO_SIGNAL';
      $('mBlock').textContent = block;
      drawEquityCurve($('equityCanvas'), result.equityCurve);
      logInstitutional({
        regime: 'BACKTEST',
        breakoutFlag: true,
        atrExp: true,
        volExp: true,
        momentumScore: null,
        probability: null,
        rollingNetExpectancy: result.expectancy,
        edgeTradesCount: Number(experimentalState.edgeEngine?.tradesCount || 0),
        edgeOk: true,
        decision: (result.trades || 0) > 0 ? 'RUN_OK' : 'RUN_EMPTY',
        reason: (result.trades || 0) > 0 ? 'TRADES_GENERATED' : `no signals due to ${block}`,
        slippageEst: modelType === 'momentum' ? 0.0006 : (modelType === 'score' ? 0.0007 : 0.0008)
      });
    }

    function renderGridResults(res){
      const tbody = $('gridTable').querySelector('tbody');
      const rows = Array.isArray(res?.top10) ? res.top10 : [];
      tbody.innerHTML = rows.map((r, idx) => `
        <tr>
          <td>${idx + 1}</td>
          <td>${Number(r.params.stopAtrMult).toFixed(2)}</td>
          <td>${Number(r.params.rTarget).toFixed(2)}</td>
          <td>${Number(r.params.breakoutLookback)}</td>
          <td>${Number(r.params.chopSlopeNorm).toFixed(2)}</td>
          <td>${Number(r.params.bullSlopeNorm).toFixed(2)}</td>
          <td>${Number(r.trades || 0)}</td>
          <td>${fmtUsd(r.netProfit || 0)}</td>
          <td>${fmtUsd(r.expectancy || 0)}</td>
          <td>${fmtPct(r.maxDD || 0)}</td>
          <td>${r.rejected ? 'REJECTED' : 'OK'}</td>
        </tr>
      `).join('');
      $('gridSummary').textContent = `Combos: ${res?.totalCombos || 0} · Válidos: ${res?.validCount || 0} · Best: ${res?.best ? 'encontrado' : 'nenhum'}`;
    }

    async function runGridUI(){
      const symbol = $('gsSymbol').value.trim().toUpperCase();
      const interval = $('gsInterval').value;
      const modelType = $('gsModel').value;
      const limit = Math.max(260, Number($('gsLimit').value || 1200));
      const series = await loadSeries(symbol, interval, limit);
      const res = runGridSearch(symbol, series, defaultGrid(), modelType, {
        edgeEngineFactory: () => new EdgeEngine(50)
      });
      lastGridBest = res?.best || null;
      renderGridResults(res);
      if (lastGridBest){
        logInstitutional({
          regime: 'GRID',
          breakoutFlag: true,
          atrExp: true,
          volExp: true,
          momentumScore: null,
          probability: null,
          rollingNetExpectancy: lastGridBest.expectancy,
          edgeTradesCount: Number(lastGridBest.trades || 0),
          edgeOk: true,
          decision: 'GRID_DONE',
          reason: `best expectancy=${Number(lastGridBest.expectancy || 0).toFixed(4)}`,
          slippageEst: 0
        });
      }
    }

    function applyBestParams(){
      if (!lastGridBest?.params) return;
      experimentalState.cfg = mergeExperimentalCfg(experimentalState.cfg, lastGridBest.params);
      $('gridSummary').textContent = `${$('gridSummary').textContent} · Params aplicados ao experimental cfg`;
      logInstitutional({
        regime: 'GRID',
        breakoutFlag: true,
        atrExp: true,
        volExp: true,
        momentumScore: null,
        probability: null,
        rollingNetExpectancy: Number(lastGridBest.expectancy || 0),
        edgeTradesCount: Number(experimentalState.edgeEngine?.tradesCount || 0),
        edgeOk: true,
        decision: 'APPLY_BEST',
        reason: JSON.stringify(lastGridBest.params),
        slippageEst: 0
      });
    }

    $('btnScan').addEventListener('click', runScanner);
    $('btnBacktest').addEventListener('click', runBacktestUI);
    $('btnRunGrid').addEventListener('click', runGridUI);
    $('btnApplyBest').addEventListener('click', applyBestParams);
    setInterval(() => { $('labClock').textContent = new Date().toLocaleTimeString('pt-BR',{hour12:false}); }, 1000);
    runScanner();
  </script>
</body>
</html>

